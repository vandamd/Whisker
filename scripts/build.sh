#!/bin/bash
# Build script for Whisker
# Creates an app bundle using Swift Package Manager

set -e

APP_NAME="Whisker"
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
BUILD_DIR="$ROOT/build"
APP_BUNDLE="$BUILD_DIR/$APP_NAME.app"
XCODE_APP="/Applications/Xcode-26.2.0.app"

cd "$ROOT"

echo "Building $APP_NAME..."

# Use Xcode's toolchain
export DEVELOPER_DIR="$XCODE_APP/Contents/Developer"

# Patch KeyboardShortcuts to avoid Bundle.module crash
patch_keyboard_shortcuts() {
  local util_path="$ROOT/.build/checkouts/KeyboardShortcuts/Sources/KeyboardShortcuts/Utilities.swift"
  if [[ ! -f "$util_path" ]]; then
    return 0
  fi
  if grep -q "keyboardShortcutsSafeBundle" "$util_path"; then
    return 0
  fi

  chmod +w "$util_path" || true
  python3 - "$util_path" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
text = path.read_text()
if ".keyboardShortcutsSafeBundle" in text:
    sys.exit(0)

text = text.replace(
    'NSLocalizedString(self, bundle: .module, comment: self)',
    'NSLocalizedString(self, bundle: .keyboardShortcutsSafeBundle, comment: self)',
)

inject = """
private extension Bundle {
    /// Safe lookup that avoids the fatal trap in the autogenerated `Bundle.module`
    /// when the resource bundle is not placed at the bundle root.
    static let keyboardShortcutsSafeBundle: Bundle = {
        #if os(macOS)
        if let url = Bundle.main.url(forResource: "KeyboardShortcuts_KeyboardShortcuts", withExtension: "bundle"),
           let bundle = Bundle(url: url) {
            return bundle
        }

        let rootURL = Bundle.main.bundleURL.appendingPathComponent("KeyboardShortcuts_KeyboardShortcuts.bundle")
        if let bundle = Bundle(url: rootURL) {
            return bundle
        }
        #endif

        let devURL = URL(fileURLWithPath: #file)
            .deletingLastPathComponent()  // Utilities.swift
            .deletingLastPathComponent()  // KeyboardShortcuts
            .deletingLastPathComponent()  // Sources
            .appendingPathComponent("KeyboardShortcuts_KeyboardShortcuts.bundle")
        if let bundle = Bundle(url: devURL) {
            return bundle
        }

        return Bundle.main
    }()
}
"""

marker = "}\n\n\nextension Data {"
if marker not in text:
    raise SystemExit("Marker not found in Utilities.swift; patch failed.")

text = text.replace(marker, "}\n\n" + inject + "\n\nextension Data {")
path.write_text(text)
PY
}

# First build to fetch dependencies
KEYBOARD_SHORTCUTS_UTIL="$ROOT/.build/checkouts/KeyboardShortcuts/Sources/KeyboardShortcuts/Utilities.swift"
if [[ ! -f "$KEYBOARD_SHORTCUTS_UTIL" ]]; then
  echo "Fetching dependencies..."
  swift build -c release 2>/dev/null || true
fi

# Patch KeyboardShortcuts before full build
patch_keyboard_shortcuts

# Build with Swift Package Manager
echo "Building for production..."
swift build -c release

# Create app bundle structure
rm -rf "$APP_BUNDLE"
mkdir -p "$APP_BUNDLE/Contents/MacOS"
mkdir -p "$APP_BUNDLE/Contents/Resources"

# Copy executable from SPM build
cp .build/release/Whisker "$APP_BUNDLE/Contents/MacOS/"

# Copy SwiftPM resource bundles (e.g. KeyboardShortcuts)
shopt -s nullglob
SWIFTPM_BUNDLES=(.build/release/*.bundle)
shopt -u nullglob
if [[ ${#SWIFTPM_BUNDLES[@]} -gt 0 ]]; then
  echo "Copying resource bundles..."
  for bundle in "${SWIFTPM_BUNDLES[@]}"; do
    cp -R "$bundle" "$APP_BUNDLE/Contents/Resources/"
  done
fi

# Build icon from .icon folder
ICON_FILE="assets/$APP_NAME.icon"
if [ -d "$ICON_FILE" ]; then
    echo "Building icon from $ICON_FILE..."
    ICTOOL="$XCODE_APP/Contents/Applications/Icon Composer.app/Contents/Executables/ictool"

    ICONSET_DIR="$BUILD_DIR/AppIcon.iconset"
    TMP_DIR="$BUILD_DIR/icon_tmp"
    mkdir -p "$ICONSET_DIR" "$TMP_DIR"

    MASTER_ART="$TMP_DIR/icon_art_824.png"
    MASTER_1024="$TMP_DIR/icon_1024.png"

    # Render icon with macOS Default appearance
    "$ICTOOL" "$ICON_FILE" \
        --export-image --output-file "$MASTER_ART" \
        --platform macOS --rendition Default \
        --width 824 --height 824 --scale 1

    # Pad to 1024x1024 with transparent border
    sips --padToHeightWidth 1024 1024 "$MASTER_ART" --out "$MASTER_1024" >/dev/null

    # Generate required sizes
    for sz in 16 32 64 128 256 512 1024; do
        out="$ICONSET_DIR/icon_${sz}x${sz}.png"
        sips -z "$sz" "$sz" "$MASTER_1024" --out "$out" >/dev/null
        if [ "$sz" -ne 1024 ]; then
            dbl=$((sz*2))
            out2="$ICONSET_DIR/icon_${sz}x${sz}@2x.png"
            sips -z "$dbl" "$dbl" "$MASTER_1024" --out "$out2" >/dev/null
        fi
    done

    # 512x512@2x already covered by 1024; ensure it exists
    cp "$MASTER_1024" "$ICONSET_DIR/icon_512x512@2x.png"

    # Create icns file
    iconutil -c icns "$ICONSET_DIR" -o "AppIcon.icns"

    # Cleanup temp files
    rm -rf "$TMP_DIR" "$ICONSET_DIR"

    echo "Icon built successfully"
fi

# Copy app icon
if [ -f "AppIcon.icns" ]; then
    cp AppIcon.icns "$APP_BUNDLE/Contents/Resources/"
fi

# Create Info.plist
cat > "$APP_BUNDLE/Contents/Info.plist" << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleName</key>
    <string>Whisker</string>
    <key>CFBundleDisplayName</key>
    <string>Whisker</string>
    <key>CFBundleIdentifier</key>
    <string>com.local.Whisker</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleExecutable</key>
    <string>Whisker</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleIconFile</key>
    <string>AppIcon</string>
    <key>LSMinimumSystemVersion</key>
    <string>14.0</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSHighResolutionCapable</key>
    <true/>
</dict>
</plist>
EOF

# Create PkgInfo
echo -n "APPL????" > "$APP_BUNDLE/Contents/PkgInfo"

# Cleanup temporary build artifacts (keep .build for faster rebuilds)
echo "Cleaning up..."
rm -f AppIcon.icns

echo ""
echo "Build complete: $APP_BUNDLE"
